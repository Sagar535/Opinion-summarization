{% extends "search/header1.html" %}


  {%block title%} Bar Graph{%endblock%}

  {% block content %}
  
  <script src="https://d3js.org/d3.v3.min.js"></script>t>

    <script>

    var value_pos = {{positive | safe}};
    var value_neg = {{negative | safe}};
      
      data = [
        {label:"POSITIVE", value: value_pos, color: "green"},
        {label:"NEGATIVE", value: value_neg, color:"red"}
    ];


    var div = d3.select("#bar_area").append("div").attr("class", "toolTip");

    var axisMargin = 20,
            margin = 40,
            valueMargin = 4,
            width = 500,
            height = 400,
            barHeight = (height-axisMargin-margin*2)* 0.4/data.length,
            barPadding = (height-axisMargin-margin*2)*0.6/data.length,
            data, bar, svg, scale, xAxis, labelWidth = 0;

    max = d3.max(data, function(d) { return d.value; });

    svg = d3.select('#bar_area')
            .append("svg")
            .attr("width", width)
            .attr("height", height);


    bar = svg.selectAll("g")
            .data(data)
            .enter()
            .append("g");

    bar.attr("class", "bar")
            .attr("cx",0)
            .attr("transform", function(d, i) {
                return "translate(" + margin + "," + (i * (barHeight + barPadding) + barPadding) + ")";
            });

    bar.append("text")
            .attr("class", "label")
            .attr("y", barHeight / 2)
            .attr("dy", ".35em") //vertical align middle
            .text(function(d){
                return d.label;
            }).each(function() {
        labelWidth = Math.ceil(Math.max(labelWidth, this.getBBox().width));
    });

    scale = d3.scale.linear()
            .domain([0, max])
            .range([0, width - margin*2 - labelWidth]);

    xAxis = d3.svg.axis()
            .scale(scale)
            .tickSize(-height + 2*margin + axisMargin)
            .orient("bottom");

    bar.append("rect")
            .attr("transform", "translate("+labelWidth+", 0)")
            .attr("height", barHeight)
            .attr("width", function(d){
                return scale(d.value);
            })
            .attr("fill", function(d) {
              return d.color;
            });

    bar.append("text")
            .attr("class", "value")
            .attr("y", barHeight / 2)
            .attr("dx", -valueMargin + labelWidth) //margin right
            .attr("dy", ".35em") //vertical align middle
            .attr("text-anchor", "end")
            .text(function(d){
                return (d.value+"%");
            })
            .attr("x", function(d){
                var width = this.getBBox().width;
                return Math.max(width + valueMargin, scale(d.value));
            });

    bar
            .on("mousemove", function(d){
                div.style("left", d3.event.pageX+10+"px");
                div.style("top", d3.event.pageY-25+"px");
                div.style("display", "inline-block");
                div.html((d.label)+"<br>"+(d.value)+"%");
            });
    bar
            .on("mouseout", function(d){
                div.style("display", "none");
            });

    svg.insert("g",":first-child")
            .attr("class", "axisHorizontal")
            .attr("transform", "translate(" + (margin + labelWidth) + ","+ (height - axisMargin - margin)+")")
            .call(xAxis);

      
      
//   // download ko codes
  
//   // Set-up the export button
// d3.select('#saveButton').on('click', function(){
//   var svgString = getSVGString(svg.node());
//   svgString2Image( svgString, 2*width, 2*height, 'png', save ); // passes Blob and filesize String to the callback

//   function save( dataBlob, filesize ){
//     saveAs( dataBlob, 'D3 vis exported to PNG.png' ); // FileSaver.js function
//   }
// });

// // Below are the functions that handle actual exporting:
// // getSVGString ( svgNode ) and svgString2Image( svgString, width, height, format, callback )
// function getSVGString( svgNode ) {
//   svgNode.setAttribute('xlink', 'http://www.w3.org/1999/xlink');
//   var cssStyleText = getCSSStyles( svgNode );
//   appendCSS( cssStyleText, svgNode );

//   var serializer = new XMLSerializer();
//   var svgString = serializer.serializeToString(svgNode);
//   svgString = svgString.replace(/(\w+)?:?xlink=/g, 'xmlns:xlink='); // Fix root xlink without namespace
//   svgString = svgString.replace(/NS\d+:href/g, 'xlink:href'); // Safari NS namespace fix

//   return svgString;

//   function getCSSStyles( parentElement ) {
//     var selectorTextArr = [];

//     // Add Parent element Id and Classes to the list
//     selectorTextArr.push( '#'+parentElement.id );
//     for (var c = 0; c < parentElement.classList.length; c++)
//         if ( !contains('.'+parentElement.classList[c], selectorTextArr) )
//           selectorTextArr.push( '.'+parentElement.classList[c] );

//     // Add Children element Ids and Classes to the list
//     var nodes = parentElement.getElementsByTagName("*");
//     for (var i = 0; i < nodes.length; i++) {
//       var id = nodes[i].id;
//       if ( !contains('#'+id, selectorTextArr) )
//         selectorTextArr.push( '#'+id );

//       var classes = nodes[i].classList;
//       for (var c = 0; c < classes.length; c++)
//         if ( !contains('.'+classes[c], selectorTextArr) )
//           selectorTextArr.push( '.'+classes[c] );
//     }

//     // Extract CSS Rules
//     var extractedCSSText = "";
//     for (var i = 0; i < document.styleSheets.length; i++) {
//       var s = document.styleSheets[i];
      
//       try {
//           if(!s.cssRules) continue;
//       } catch( e ) {
//             if(e.name !== 'SecurityError') throw e; // for Firefox
//             continue;
//           }

//       var cssRules = s.cssRules;
//       for (var r = 0; r < cssRules.length; r++) {
//         if ( contains( cssRules[r].selectorText, selectorTextArr ) )
//           extractedCSSText += cssRules[r].cssText;
//       }
//     }
    

//     return extractedCSSText;

//     function contains(str,arr) {
//       return arr.indexOf( str ) === -1 ? false : true;
//     }

//   }

//   function appendCSS( cssText, element ) {
//     var styleElement = document.createElement("style");
//     styleElement.setAttribute("type","text/css"); 
//     styleElement.innerHTML = cssText;
//     var refNode = element.hasChildNodes() ? element.children[0] : null;
//     element.insertBefore( styleElement, refNode );
//   }
// }


// function svgString2Image( svgString, width, height, format, callback ) {
//   var format = format ? format : 'png';

//   var imgsrc = 'data:image/svg+xml;base64,'+ btoa( unescape( encodeURIComponent( svgString ) ) ); // Convert SVG string to data URL

//   var canvas = document.createElement("canvas");
//   var context = canvas.getContext("2d");

//   canvas.width = width;
//   canvas.height = height;

//   var image = new Image();
//   image.onload = function() {
//     context.clearRect ( 0, 0, width, height );
//     context.drawImage(image, 0, 0, width, height);

//     canvas.toBlob( function(blob) {
//       var filesize = Math.round( blob.length/1024 ) + ' KB';
//       if ( callback ) callback( blob, filesize );
//     });

    
//   };

//   image.src = imgsrc;
// }




    </script>

  {% endblock%}